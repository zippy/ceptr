<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Semtrex Article</title>
</head>

<body>

<p><img border="0" src="ide.png" width="917" height="507"></p>
<h2>Source Code</h2>
<p>The C and C# code discussed in this article can be found here:</p>
<p><a href="https://github.com/zippy/ceptr">https://github.com/zippy/ceptr</a>
</p>
<p>A good blog post (including a couple videos!) on the concept of Ceptr and 
Semtrex can be found here:</p>
<p><a href="http://ceptr.org/2015/04/06/semantic-trees/">
http://ceptr.org/2015/04/06/semantic-trees/</a> </p>
<h2>Introduction</h2>
<p>In this article, I would like to introduce you to the work of Eric
Harris-Braun and Arthur Brock.&nbsp; They have been working on a concept that
they call &quot;Semtrex&quot; - a semantic tree regular expression matcher, as part of a larger
project called &quot;Ceptr.&quot; </p>
<p>Two cornerstone of the Ceptr <i>concept</i> are:</p>
<ol>
	<li>data always carries with it its semantics, in other words, the qualities
	that give the data meaning</li>
	<li>the meaning (semantics) of something is very naturally expressed as tree
	structures</li>
</ol>
<p>As a result of these premises, it became clear that, similar to how we have a
regular expression (Regex) matcher for one-dimensional strings, a tree
expression matcher is needed for trees of two or more dimensions.&nbsp;
Furthermore, because the trees incorporate meaning (semantics), the tree
expression matcher must be a <i>semantic</i> tree regular expression matcher.&nbsp; Here
we see another divergence from Regex -- Semtrex matches on the semantics of the
data as well as literal values, whereas Regex, having no concept of the
semantics on which it is matching, can match only on the literal values.</p>
<p>This introduces some new and interesting behaviors to pattern matching --
matching not just the literal values of the data but also the semantic
meaning of the data.&nbsp; Thus, the while &quot;42&quot; matches with the
literal &quot;42&quot;, &quot;42 years
old&quot; does not match with &quot;42 is the answer to the ultimate question of life, the
universe, and everything.&quot;</p>
<h2>The Nature of Nature</h2>
<p>Let's consider why semantic trees are important and, to be rather bold about
it, actually necessary for the future evolution of computing, communication, and
data exchange.&nbsp; There are both philosophical and concrete, computational
reasons, each guiding the other in understanding.&nbsp; We will consider how
everything in nature (though our focus is on data) has two characteristics:
meaning and structure (relationship.)&nbsp; </p>
<h3>The Nature of Meaning</h3>
<p>&quot;Semantics is the study of meaning.&quot;<sup>1</sup> In order for
information to have value, that information must have meaning.&nbsp; The term
&quot;value&quot; can be interpreted as meaning both &quot;valuable&quot; and &quot;computable.&quot;&nbsp;
Information is not <i>valuable</i> unless it is meaningful.&nbsp; Information
has values on which to base computations.&nbsp; So, by value,
we mean in part that computations can be performed on that value or that the
value is itself part of a computation involving many other values, and that we
find both the values and the computations <i>valuable.</i> Take,
for example, the Semantic Web<sup>3</sup> which &quot;provides a common framework that allows
data to be shared and reused across application, enterprise, and community
boundaries.&quot;<sup>3</sup>&nbsp; Note that the term itself was coined by Tim
Berners-Lee<sup>4</sup> for a web of data that can be processed by machines.<sup>5</sup></p>
<h3>The Meaning of Nature</h3>
<p>Nature is relational -- from the most fundamental theoretical models of quantum physics
to largest macrocosmic scale of physical galaxies, we constantly see that &quot;things&quot; are in
relationship with other &quot;things.&quot;&nbsp; Furthermore, these relationships have
structure which we humans, with great frequency, map into a hierarchical,
tree-like space.&nbsp; We do this with organizational charts, phylogeny, and
family trees.&nbsp; We use parse trees<sup>7</sup> for parsing a
context-free grammar.&nbsp; Compilers take our linear code and parse it into BNF<sup>8</sup>
trees to generate (again linear) machine code. </p>
<p>Structure (the relationship between values) is also a necessary component of
meaning and therefore of computation.&nbsp; Just as you cannot perform a
computation on a value without at least an implicit semantic understanding of
what that value is, you cannot perform computations on groups of values without
having a defined structure that relates those values to each other.&nbsp;
Furthermore, that structure (the defining of relationships) itself creates new
meaning.</p>
<h3>Meaning: Symbols and Structures</h3>
<p>Eric Harris-Braun: &quot;Meaning comes from having a social context in which 
symbols are applied to embodied forms (structures!)&quot;</p>
<p>Arthur Brock: &quot;Meaning comes from understanding the use of a symbol in a 
specific context.&nbsp; A context means a collection of symbols used in a 
particular way.&quot;</p>
<p>For example, here is an ottoman used as a table, a footstool, and a chair.&nbsp; </p>
<p><img border="0" src="ott1.png" width="256" height="455"></p><p><img border="0" src="ott2.png" width="256" height="455"></p><p><img border="0" src="ott3.png" width="455" height="256"></p>
<p align="center">(Arthur Brock working, relaxing, and play chess with Eric 
Harris-Braun)</p>
<p>The context provides essential additional meaning to the symbol &quot;ottoman.&quot;</p>
<p>Structure (the defining of relationships) creates new meaning is a key point, and while it is (and in fact must be) self-reflective or
&quot;fractal&quot;,
it explains why we explicitly (or implicitly) create hierarchical structures.&nbsp;
For example, given something we want to measure, we assign a symbol to
it--inches, feet, kilograms, light-years.&nbsp; This gives the measurement a
semantic context.&nbsp; We see this &quot;thing&quot; in relationship with other &quot;things&quot; that also
have semantic meaning, and so we create a structure that maps the relationship
of those &quot;things.&quot;&nbsp; That structure is itself assigned a semantic meaning,
and so on, recursing in a fractal manner either up or down the hierarchies that
we are creating, allowing us to express more and more complex and interesting
concepts and relationships between those concepts.&nbsp; </p>
<p>Eric Harris-Braun: &quot;This is an important pattern in the real world and in programming (&quot;has a&quot;
relationship).&nbsp; This pattern of alternation is a fundamental pattern
(programming languages, real world, etc) what we're trying to do in Ceptr is
make that fundamental pattern explicit and have some self knowledge of what
we're doing.&quot;</p>
<p>Arthur Brock: &quot;What we're doing in Ceptr ... when you program, the programmer has to deal
with these things as meaningful units (variable names) but then when we compile
it, it all goes away, collapsed down to structured data in memory addresses.&nbsp; We then have difficulty sharing the meaning, we have to then construct a
semantic layer where we &quot;hydrate&quot; the meaning back into the structure.&quot;</p>
<h3>Living Meaning</h3>
<p>Meaning is not static and this is a major contributor to why software
becomes obsolete: software is incapable of adapting, beyond a certain limit, to
changes in meaning.&nbsp;&nbsp; </p>
<ul>
	<li>Values change -- they are created, destroyed, and changed.&nbsp; This
	happens with the greatest frequency and is the only change that modern day
	software typically handles well (without programmer intervention.)</li>
	<li>Relationships between values change -- old relationships become
	&quot;meaningless&quot;, and new relationships are necessary between new values.&nbsp;
	While this happens slower, it could be argued to be the primary reason for
	why software needs to be updated and eventually replaced.&nbsp; For example,
	the lifetime of a relational database, which is expressing fixed
	relationship in tables and foreign keys, is limited by the ability to
	accommodate new relationships (new tables, changes in foreign keys, etc.)</li>
	<li>Meaning itself changes, albeit very slowly over time.&nbsp; For example,
	consider how the meaning of the word &quot;gay&quot; has changed over time.</li>
	<li>New structures are formed and given semantic meaning.&nbsp; One can observe
	how computer languages have evolved as new structures are incorporated into the
	language, such as lambda expressions, anonymous methods, and C#'s async/await
	keywords, all of which express older concepts in more efficient semantics.</li>
</ul>
<h3>Semtrex</h3>
<p>Realizing that meaning involves semantics and structure, Semtrex is a
cornerstone to a much larger &quot;rewrite&quot; of the computing space in which we currently live.&nbsp; At present, our computational space takes semantically
structured data, decouples the semantic meaning and structure into raw data
streams or storage (with or without a separate schema), and then re-assembles that data into
either the same or different semantic structures.&nbsp; Ironically, this is the
impetus for a new field of information and computer science called ontology
engineering &quot;which studies the methods and methodologies for building ontologies:
formal representations of a set of concepts within a domain and the
relationships between those concepts.&quot;<sup>9</sup></p>
<p>For example, the SMTP Specification<sup>10</sup> defines, among other things,
the structure and semantics of email addresses.&nbsp; When we write &quot;foo@biz.eu&quot;,
we strip off the structure and semantic meaning and in fact store and transmit
the email address with none of its original structure or semantics.&nbsp; When
we write a mail server, we have to &quot;parse&quot; the email address, &quot;hydrating&quot; its
structure and the semantics of its constituent parts so that we can perform
computations on the address such as validation, verification, checking against
white lists, black lists, perform billing, and so forth.&nbsp; Furthermore, the
system is very rigid.&nbsp; For example, we cannot send an email to a physical
address which could be handled by a system that physically prints and mails the
content.&nbsp; We cannot send an email to a phone number which would then dial
the phone and read the content with text-to-speech synthesis.&nbsp; We cannot
send an email to a mobile phone's text messaging service.&nbsp; Why?&nbsp;
Because the mail server must <i>assume</i> a specific semantic meaning to the
value in the &quot;mail-to&quot; slot--it must be an email address--because the &quot;mail-to&quot;
slot does not carry along with it the semantics of its value.</p>
<h3>Edge Space</h3>
<p>A cornerstone of the Ceptr <i>architecture</i> is that it operates
exclusively with semantic data and therefore semantic trees.&nbsp; In the
broader picture, Ceptr provides a means for processing semantic data in virtual
machine &quot;receptors.&quot;&nbsp; Data is moved in and out of receptors as semantic
packages, or signals, which embody of course both the data and the semantics
corresponding to that data.&nbsp; In this way, receptors only process those
things that have semantic meaning to them.</p>
<p>However, the rest of the world does not usually exchange semantic information
-- instead, it's often raw binary data or human-readable ASCII strings (like
this article.)&nbsp; We see some introduction of semantic meaning in XML and
JSON packets, both in their ability to structure the data and associate
attribute names (or keys) to the data.&nbsp; However, even with XML and JSON,
the attribute and keys are often high level abstractions, like &quot;address&quot; or
&quot;full name&quot;, or domain-specific, like &quot;domicile&quot; and &quot;maiden name.&quot;&nbsp; In the
former, a program parsing the data does not know that &quot;address&quot; actually refers,
semantically, to a home address, vacation address, or business address (of many
options) and in the latter case, again a program parsing the key &quot;domicile&quot;
(which may have semantic meaning to the programmer that wrote the XML or JSON)
probably requires a &quot;translation&quot; to the semantic meaning &quot;home address.&quot;</p>
<p>While this leaves the world with an almost infinite need for programmers to
constantly reformat one semantically poor data structure into another, equally
poor, semantic data structure, it still leaves us with the real world issue that
this problem does indeed exist.&nbsp; This is the &quot;edge space&quot; where &quot;data&quot; in
the outside world and semantic data inside of Ceptr is translated.</p>
<h2>Starting with an Example</h2>
<p>Marc Clifton has built a simple IDE (implemented in C#) around the C code to
provide a playground for working with Semtrex expression matching.&nbsp; We take
the example of parsing a latitude and longitude from an ASCII string into a
Semtrex and performing some match tests on it.</p>
<h3>Building the Symbol and Structure Tree</h3>
<p>The first step is to define the structures and their symbols.&nbsp; When we
fire up the IDE, we're presented with an empty Symbol Tree.&nbsp; Let's create a
container for our demo lat/lon symbols &amp; structures:</p>
<p><img border="0" src="namespace1.png" width="510" height="113"></p>
<p>Click on &quot;Symbol Namespace&quot; and provide a name for the container.&nbsp; Here,
I use &quot;latlon demo&quot;:</p>
<p><img border="0" src="namespace2.png" width="510" height="111"></p>
<p>Right-click on the &quot;latlon demo&quot; container and select &quot;Add Symbol&quot; from the
popup menu:</p>
<p><img border="0" src="addSymbol.png" width="338" height="227"></p>
<p>We can now define the symbol and structure names in the Properties pane:</p>
<p><img border="0" src="addSymbol2.png" width="510" height="129"></p>
<p>We'll assume that this is a &quot;home location&quot;, so we give name the <i>symbol</i>
&quot;HomeLocation&quot; and specify that the <i>structure</i> is a &quot;latlon&quot;:</p>
<p><img border="0" src="latlon1.png" width="512" height="135"></p>
<p>We also see the symbol and structure listed in the Symbols and Structures
panes:</p>
<p><img border="0" src="symstruct1.png" width="324" height="76"></p>
<p>Next, we define the &quot;latlon&quot; structure.&nbsp; This structure consists of two
symbols whose structure is &quot;float&quot;:</p>
<p><img border="0" src="latlon2.png" width="425" height="225"></p>
<p>As the above screenshot illustrates, there is a short list of built-in
structures from which one can also choose.&nbsp; Keep in mind that we could even
define what we mean by the structure &quot;float&quot; -- we could in fact define it as
two integers (again structures of bits) with the symbols &quot;mantissa&quot; and
&quot;exponent.&quot;&nbsp; This process can be repeated down to the atomic level (and
further) of capacitance charge in memory cells.</p>
<p><img border="0" src="symstruct2.png" width="299" height="100"></p>
<p>We now have our symbols and structures defined for parsing a latlon string.</p>
<h3>Converting a String to an ASCII Tree</h3>
<p>Because, Semtrex is a <i>tree expression matcher,</i> any input string must
be converted to an ASCII tree.&nbsp; This is by intent, as it keeps the parser
code uniform in that it is always working with trees.&nbsp; An &quot;ASCII Tree&quot;, which
consists of nothing more than a root node and where each of the children is a
single character in the string, is necessary to convert strings into a tree
structure on which Semtrex can operate.&nbsp; While this sounds silly, it allows us to
stay in the unified world of semantic trees as the input for Semtrex.&nbsp;
Another way to put it is, we are describing the string semantically with as much
meaning as we can give it at the moment: &quot;a string of ASCII characters&quot; which we
wrap into an ASCII Tree <i>representation.</i>&nbsp; We don't know what the
string is or what it contains, but now that we've got it in a tree structure, we
can parse it.</p>
<p>Given a latlon input string:</p>
<p><img border="0" src="parse1.png" width="549" height="94"></p>
<p>We can parse this into an ASCII Tree by clicking &quot;Parse to ASCII Tree&quot;.&nbsp;
The result is displayed in the Semtrex Tree textbox (only a piece is shown here,
you get the idea):</p>
<p><img border="0" src="parse2.png" width="408" height="322"></p>
<p>Or, visualized with a D3 tree (fragment shown):</p>
<p><img border="0" src="tree1.png" width="236" height="379"></p>
<p>The root of the tree is a symbol &quot;ASCII_CHARS&quot; and each element of the tree
is a structure-value pair &quot;ASCII_CHAR&quot; and the value of the char.</p>
<h4>Matching on the ASCII Tree</h4>
<p>Now that we have the string represented as a tree, we can write a Semtrex
expression to match against the tree:</p>
<pre>/ASCII_CHARS/&lt;HomeLocation:&lt;lat:ASCII_CHAR+&gt;,ASCII_CHAR=',',&lt;lon:ASCII_CHAR+&gt;&gt;</pre>
<p>Note how this expression not only matches against the format of the input
string but also specifies the symbols associated with the structural components
of the tree-ified string.</p>
<p>What the above Semtrex expression is doing is as follows:</p>
<ul>
	<li>The angle brackets indicate that we are on the fly naming (or assigning
	a semantic symbol) the matching part of the input string. </li>
<li>In this case, we're creating a symbol:&quot;lat&quot;&nbsp;which will hold the ASCII_CHARS
preceding the comma, and one called &quot;lon&quot; which will hold the symbols after the
comma.</li>
	<li>Then &quot;HomeLocation&quot; is a symbol tree with &quot;lat&quot; and &quot;lon&quot; as its two
	children.</li>
<li>Those named symbols (assuming there are definitions in the system for how
they're structured) can be used in later Semtrex matches on the match output
they produce.</li>
</ul>
<p>We enter the Semtrex expression in the next line and click on Parse:</p>
<p><img border="0" src="parse3.png" width="562" height="143"></p>
<p><img border="0" src="key-small.png" width="94" height="33"></p>
<p>Why do we do this?&nbsp; Because we've specified a Semtrex expression as a
string, which itself must be first converted into a tree!&nbsp; So you can see
the pattern here: inputs are semantic trees, expressions are semantic trees,
and Semtrex matches input trees against expression trees.&nbsp; In fact, all
output from Semtrex is a semantic tree as well.</p>
<p>The result of the parse operation can be viewed as well, shown here in full:</p>
<pre>
(
  SEMTREX_SYMBOL_LITERAL
  (
    SEMTREX_SYMBOL:ASCII_CHARS
  )
  (
    SEMTREX_GROUP:HomeLocation
    (
      SEMTREX_SEQUENCE
      (
        SEMTREX_GROUP:lat
        (
          SEMTREX_ONE_OR_MORE
          (
            SEMTREX_SYMBOL_LITERAL
            (
              SEMTREX_SYMBOL:ASCII_CHAR
            )
          )
        )
      )
      (
        SEMTREX_VALUE_LITERAL
        (
          ASCII_CHAR:','
        )
      )
      (
        SEMTREX_GROUP:NULL_SYMBOL
        (
          SEMTREX_ONE_OR_MORE
          (
            SEMTREX_SYMBOL_LITERAL
            (
              SEMTREX_SYMBOL:ASCII_CHAR
            )
          )
        )
      )
    )
  )
)</pre>
<p>Again, as a D3 tree:</p>
<p><img border="0" src="tree2.png" width="414" height="444"></p>
<h3>Does The Input Match?</h3>
<p>Now we can ask, &quot;does the input tree match the expected format as specified
by the Semtrex match expression?&quot;&nbsp; We ask this by clicking on the
&quot;Matches?&quot; button:</p>
<p><img border="0" src="parse4.png" width="549" height="186"></p>
<p>And the answer is True:</p>
<p><img border="0" src="parse5.png" width="546" height="185"></p>
<p>Furthermore, we also can also ask Semtrex <i>how</i> it matches, which is
also a tree:</p>
<pre>(
  SEMTREX_MATCH:1
  (
    SEMTREX_MATCH_SYMBOL:HomeLocation
  )
  (
    SEMTREX_MATCH_PATH:/1
  )
  (
    SEMTREX_MATCH_SIBLINGS_COUNT:11
  )
  (
    SEMTREX_MATCH:3
    (
      SEMTREX_MATCH_SYMBOL:lat
    )
    (
      SEMTREX_MATCH_PATH:/1
    )
    (
      SEMTREX_MATCH_SIBLINGS_COUNT:5
    )
  )
  (
    SEMTREX_MATCH:2
    (
      SEMTREX_MATCH_SYMBOL:lon
    )
    (
      SEMTREX_MATCH_PATH:/7
    )
    (
      SEMTREX_MATCH_SIBLINGS_COUNT:5
    )
  )
)</pre>
<p>In D3:</p>
<p><img border="0" src="tree3.png" width="262" height="576"></p>
<p>Notice how the above match result expression tells us with which symbol the
structure and it's data is associated.</p>
<h3>Embodiment</h3>
<p>We can now &quot;embody&quot; the symbols with their values.&nbsp; We now have a
structure with meaning -- a semantic structure.&nbsp; We do this by clicking on
the &quot;Embody&quot; button:</p>
<p><img border="0" src="parse6.png" width="547" height="231"></p>
<p>and we see the result:</p>
<p><img border="0" src="parse7.png" width="117" height="212"></p>
<p>Again, as a D3 tree:</p>
<p><img border="0" src="tree4.png" width="125" height="337"></p>
<h3>Matching Against An Embodied Tree</h3>
<p>All of the steps above were actually necessary simply to convert an input
string into a semantic tree.&nbsp; The nifty thing is that this was done using
Semtrex itself.&nbsp; However, now we arrive at the meat and potatoes of the
matter.&nbsp; Let's say data was always semantic -- in other words, what you
received as your input was not a relatively meaningless string (albeit perhaps
human readable after some training) but a structure that was meaningful <i>to
the machine</i>.&nbsp; This:</p>
<p><img border="0" src="parse7.png" width="117" height="212"></p>
<p>is meaningful to the machine.&nbsp; We can now ask the machine to match
against it, both structurally and the values it contains.&nbsp; Here's a Semtrex
expression that matches:</p>
<pre>/%HomeLocation/(lat=42.25,lon=73.25)</pre>
<p>And we can test this with the Matches? button, which returns true.&nbsp; The
astute reader will say, but wait!&nbsp; That input is a string an must, like the
previous match expression, be turned into a Semtrex expression first!&nbsp; And
you are correct, which is why we must first parse the (sort of) human readable
input string into a Semtrex expression:</p>
<pre>(
  SEMTREX_WALK
  (
    SEMTREX_SYMBOL_LITERAL
    (
      SEMTREX_SYMBOL:HomeLocation
    )
    (
      SEMTREX_SEQUENCE
      (
        SEMTREX_VALUE_LITERAL
        (
          lat:42.250000
        )
      )
      (
        SEMTREX_VALUE_LITERAL
        (
          lon:73.250000
        )
      )
    )
  )
)</pre>
<p>And the last D3 graph rendering:</p>
<p><img border="0" src="tree5.png" width="365" height="403"></p>
<p>So here you finally see the whole playground:</p>
<p><img border="0" src="parse8.png" width="553" height="661"></p>
<h2>Building The Semtrex C Code</h2>
<p>Semtrex (the parser, specs, and symbol management) are written in C.&nbsp;
Eric chose the C language because it is ubiquitous among a wide variety of
platforms, everything from Arduino's to, of course, Windows and Linux.&nbsp; </p>
<h3>Compiling the C Code</h3>
<p>The simplest way to build the C code is to download Eclipse and open the
Eclipse project in the Ceptr GitHub repository.&nbsp; The resulting dll file can
be copied into the C# bin\Debug or bin\Release folder.</p>
<h2>The C# IDE</h2>
<p>The IDE is organized into two projects -- &quot;csharp-ide&quot; is the IDE UI.&nbsp;
Readers may be familiar with other articles written by Marc Clifton which take
advantage of the same approach:</p>
<ul>
	<li>WeifenLuo's Docking Manager.</li>
	<li>MycroParser used for the UI definition and event wire-up.</li>
	<li>MVC pattern for separating out the model, view, and controllers for each
	of the dockable panes.</li>
	<li>XTree - a general purpose tree builder.</li>
</ul>
<p>The second project (&quot;ceptrlib&quot;) is the interface
to Eric's C code, which must be built with the &quot;allow unsafe code&quot; option.&nbsp;
There are several structures, for example:</p>
<pre>[StructLayout(LayoutKind.Sequential, Pack = 1), Serializable]
public unsafe struct Defs
{
  public TreeNode *structures;
  public TreeNode *symbols;
  public TreeNode *processes;
  public TreeNode *scapes;
};</pre>
<p>These must be marked as unsafe to fix the error &quot;Pointers and fixed size
buffers may only be used in an unsafe context.&quot;</p>
<h3>The C# / C Interface</h3>
<p>The C calls are made using the DllImport attribute.&nbsp; There are a few:</p>
<pre>// Initialize the the 'C' library.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static void def_sys();

// Free any allocated memory.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static void sys_free();

// Create the root of a tree.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe TreeNode* _t_new_root(SemanticID sid);

// Declare a symbol.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe SemanticID _d_declare_symbol(TreeNode* symbols, SemanticID sid, string label, UInt16 context);

// Define a structure with a variable # of parameters.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe SemanticID _dv_define_structure(TreeNode* structures, [MarshalAs(UnmanagedType.LPStr)] string label, int num_params, __arglist);

// Return the number of children in a node.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe int _t_children(TreeNode* structures);

// Generate a human-readable dump of a tree.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
// [return: MarshalAs(UnmanagedType.LPStr)]
extern static unsafe void __t_dump(Defs* defs, TreeNode* t, int level, char* buf);

// Create an ASCII tree from an input string.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe TreeNode* makeASCIITree(string stx);

// Parse a Semtrex string into a Semtrex tree.
[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe TreeNode* parseSemtrex(Defs* d, string stx);

[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe int _t_match(TreeNode* semtrex, TreeNode* matchAgainst);

[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe int _t_matchr(TreeNode* semtrex, TreeNode* matchAgainst, TreeNode** matchResult);

[DllImport(&quot;libceptrlib.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
extern static unsafe TreeNode* _t_embody_from_match(Defs* d, TreeNode* matchResult, TreeNode* semtrex);</pre>
<h4>Initialization and Termination</h4>
<p>Having the necessary imported 'C' functions above, we can implement all that
is necessary for initializing and terminating the 'C' library:</p>
<pre>public unsafe void Initialize()
{
  def_sys();
}

public unsafe void Terminate()
{
  sys_free();
}</pre>
<h4>Initializing Structure and Symbol Trees</h4>
<p>These are stored as separate trees, and we initialize them with:</p>
<pre>public void CreateStructureAndSymbolNodes()
{
  Structures = new SemanticID()
    {
      context = (UInt16)SemanticContexts.SYS_CONTEXT,
      flags = (UInt16)SemanticTypes.SEM_TYPE_SYMBOL,
      id = (UInt32)SystemSymbolIDs.STRUCTURES_ID
    };

  Symbols = new SemanticID()
    {
      context = (UInt16)SemanticContexts.SYS_CONTEXT,
      flags = (UInt16)SemanticTypes.SEM_TYPE_SYMBOL,
      id = (UInt32)SystemSymbolIDs.SYMBOLS_ID
    };

  RootStructuresNode = CreateRootNode(Structures);
  RootSymbolsNode = CreateRootNode(Symbols);
}</pre>
<p>In the C implementation, a SemanticID consists of: </p>
<ul>
	<li>A context in which it is defined (16 bits). This may specify a local
	receptor, the code installed in a system or from a compository of code and
	receptors.</li>
	<li>Flags are a middle 16 bits reserved for flags about the symbol.</li>
<li>ID is a unique identifier to that context and type.</li>
</ul>
<p>In other words, a symbol ID is 64 bits. 16 reserved for identifying context
of identifier, 16 reserved for markers about the type of symbol (like is it a
process, structure or a symbol, or scape or receptor or something else) and 32
for the identifier unique to that context and type, like a structure ID or
symbol ID.&nbsp; Note that one of the confusing things is that there is a symbol
		SYMBOLS_ID (plural) which holds the list of all SYMBOL_ID's. &nbsp;</p>
<p>From the C# perspective, and not wanting to require unsafe support for every
assembly that references this interface assembly, the C pointers are mapped to GUID's:</p>
<pre>public unsafe Guid CreateRootNode(SemanticID structures)
{
  TreeNode *node = _t_new_root(structures);
  Guid guid = RegisterNode(node);

  return guid;
}

protected unsafe Guid RegisterNode(TreeNode* node)
{
  Guid guid = Guid.NewGuid();
  nodes[guid] = (IntPtr)node;

  return guid;
}</pre>
<p>This way, all other assemblies can reference tree nodes using a Guid rather
than a C-style TreeNode*.&nbsp; Any node, given the Guid, can in this assembly
be restored to the TreeNode*:</p>
<pre>protected unsafe TreeNode* GetNode(Guid id)
{
  return (TreeNode*)nodes[id];
}</pre>
<h4>Internal Types</h4>
<p>There is of course a limit to how much one can realistically drill down into
the symbol-structure space, so there are several internal value types to
represent basic machine-understandable types.&nbsp; Remember, you're look at an
interface to C code here, and C has no concept of things like generics or
reflection, so all of the meaning (funny how we are talking about meaning at
both the semantic level and the code level) has to be expressed in structures
and enumerations.</p>
<pre>public SemanticID GetFloat()
{
  SemanticID sid = new SemanticID()
  {
    context = (UInt16)SemanticContexts.SYS_CONTEXT,
    flags = (UInt16)SemanticTypes.SEM_TYPE_STRUCTURE,
    id = (UInt32)SystemStructureID.FLOAT_ID
  };

  return sid;
}

public SemanticID GetString()
{
  SemanticID sid = new SemanticID()
  {
    context = (UInt16)SemanticContexts.SYS_CONTEXT,
    flags = (UInt16)SemanticTypes.SEM_TYPE_STRUCTURE,
    id = (UInt32)SystemStructureID.CSTRING_ID
  };

  return sid;
}

public SemanticID GetInteger()
{
  SemanticID sid = new SemanticID()
  {
    context = (UInt16)SemanticContexts.SYS_CONTEXT,
    flags = (UInt16)SemanticTypes.SEM_TYPE_STRUCTURE,
    id = (UInt32)SystemStructureID.INTEGER_ID
  };

  return sid;
}

public SemanticID GetList()
{
  SemanticID sid = new SemanticID()
  {
    context = (UInt16)SemanticContexts.SYS_CONTEXT,
    flags = (UInt16)SemanticTypes.SEM_TYPE_STRUCTURE,
    id = (UInt32)SystemStructureID.LIST_ID
  };

  return sid;
}</pre>
<h4>Declaring Symbol and Structures</h4>
<p>Here we declare a symbol:</p>
<pre>public unsafe SemanticID DeclareSymbol(Guid symbols, SemanticID st, string label, SemanticContexts sc = SemanticContexts.RECEPTOR_CONTEXT)
{
  TreeNode *pnode = (TreeNode*)nodes[symbols];
  SemanticID symbol = _d_declare_symbol(pnode, st, label, (UInt16)sc);

  return symbol;
}</pre>
<p>and a structure:</p>
<pre>public unsafe SemanticID DefineStructure(Guid structures, string name, SemanticID[] symbolArray, SemanticContexts sc = SemanticContexts.RECEPTOR_CONTEXT)
{
  TreeNode *structs = (TreeNode*)nodes[structures];

  _dv_define_structure(structs, name, symbolArray.Length, __arglist(symbolArray));
  SemanticID st = new SemanticID() { context = (ushort)sc, flags = (ushort)SemanticTypes.SEM_TYPE_STRUCTURE, id = (uint)_t_children(structs) };

  return st;
}</pre>
<p>Remember that a structure (like &quot;latlon&quot;) is actually a collection of symbols
(&quot;lat&quot; and &quot;lon&quot;), therefore we pass in the symbols that comprise the structure.</p>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; You should start to see a pattern here -- every piece of symbol and structure
is an instance of <code>SemanticID</code>, whether it is a user defined symbol/structure or a
system defined symbol/structure.</p>
<h4>Converting a String to an ASCII Tree</h4>
<p>This is a straight forward process now:</p>
<pre>public unsafe Guid GetTree(string str)
{
  TreeNode* node = makeASCIITree(str);
  Guid nodeID = RegisterNode(node);

  return nodeID;
}</pre>
<h4>Parse the Semtrex Expression</h4>
<pre>public unsafe Guid ParseSemtrex(Guid g_symbols, Guid g_structures, string expression)
{
  Defs defs = CreateDefs(g_symbols, g_structures);
  TreeNode* node = parseSemtrex(&amp;defs, expression);
  Guid nodeID = RegisterNode(node);

  return nodeID;
}</pre>
<h4>Embody the Match Results</h4>
<pre>public unsafe Guid Embody(Guid g_symbols, Guid g_structures, Guid matchID, Guid semtrexID)
{
  Defs defs = CreateDefs(g_symbols, g_structures);
  TreeNode* match = GetNode(matchID);
  TreeNode* semtrex = GetNode(semtrexID);
  TreeNode* resultTree = _t_embody_from_match(&amp;defs, match, semtrex);

  return RegisterNode(resultTree);
}</pre>
<h4>Match A Tree</h4>
<pre>public unsafe Tuple&lt;bool, Guid&gt; Match(Guid semtrexID, Guid treeToMatchID)
{
  TreeNode* semtrex = GetNode(semtrexID);
  TreeNode* treeToMatch = GetNode(treeToMatchID);
  TreeNode* resultTree;
  int matchState = _t_matchr(semtrex, treeToMatch, &amp;resultTree);
  Guid guid = Guid.Empty;

  if (matchState == 1)
  {
    guid = RegisterNode(resultTree);
  }

  return new Tuple&lt;bool, Guid&gt;(matchState == 1, guid);
}</pre>
<h4>Testing the Match</h4>
<pre>public unsafe bool MatchTest(Guid semtrexID, Guid matchAgainstID)
{
  TreeNode* semtrex = GetNode(semtrexID);
  TreeNode* matchAgainst = GetNode(matchAgainstID);
  int ret = _t_match(semtrex, matchAgainst);

  return ret == 1;
}</pre>
<h3>Putting the Pieces Together</h3>
<p>In SemanticUIController.cs, you can see how all of these pieces are put
together when handling the UI events.</p>
<h4>Parsing A String to an ASCII Tree</h4>
<pre>public void CreateStructuresAndSymbols()
{
  symbolMap = new Dictionary&lt;string, SemanticID&gt;();
  structureMap = new Dictionary&lt;string, SemanticID&gt;();

  ApplicationController.CeptrInterface.CreateStructureAndSymbolNodes();

  foreach (string symbolName in ApplicationModel.SymbolRefCount.Keys)
  {
    if (!symbolMap.ContainsKey(symbolName))
    {
      // Find the symbol in the tree.
      Symbol symbol = FindSymbolInTree(symbolName, ApplicationController.SymbolEditorController.View.TreeView.Nodes);

      if (symbol == null)
      {
        throw new Exception(&quot;The symbol &quot; + symbolName + &quot; should have been found in the tree.&quot;);
      }

    SemanticID topStructure = ApplicationController.Recurse(symbol, structureMap, symbolMap);
    SemanticID symbolID = ApplicationController.CeptrInterface.DeclareSymbol(
        ApplicationController.CeptrInterface.RootSymbolsNode, topStructure, symbolName);
    symbolMap[symbolName] = symbolID;
    }
  }
}

// Convert a string to an ASCII tree.
public void ToTree(object sender, EventArgs args)
{
  CreateStructuresAndSymbols();

  asciiTreeID = ApplicationController.CeptrInterface.GetTree(View.tbInputString.Text);
  DumpOutput(asciiTreeID);
}</pre>
<p>The above code maps the symbol tree (managed simply be the .NET <code>TreeView</code>
control) into a dictionary of symbols and structures suitable for the C code to
digest.&nbsp; Once the symbols and structures have been initialized, the
interface function <code>GetTree</code> is called to return a <code>Guid</code> of the ASCII tree.</p>
<h4>Creating a Semtrex Tree from an ASCII String</h4>
<pre>public void ToSemtrex(object sender, EventArgs args)
{
  parseExprID = ApplicationController.CeptrInterface.ParseSemtrex(
    ApplicationController.CeptrInterface.RootSymbolsNode,
    ApplicationController.CeptrInterface.RootStructuresNode,
    View.tbParseExpr.Text
  );

  DumpOutput(parseExprID);
}</pre>
<h4>Matching the ASCII Input String</h4>
<p>Using the tree ID's obtained from the methods described above, we match the latlon input string against the parsed Semtrex
tree, :</p>
<pre>public void Match(object sender, EventArgs args)
{
  Tuple&lt;bool, Guid&gt; result = ApplicationController.CeptrInterface.Match(parseExprID, asciiTreeID);

  if (result.Item1)
  {
    View.tbMatchResult.Text = &quot;True&quot;;
    matchResultTreeID = result.Item2;
    DumpOutput(matchResultTreeID);
  }
  else
  {
    View.tbMatchResult.Text = &quot;False&quot;;
    View.tbSemtrexTree.Text = &quot;&quot;;
  }
}</pre>
<h4>Embody the Result</h4>
<p>We embody the match result tree with the input values:</p>
<pre>public void Embody(object sender, EventArgs args)
{
  embodyID = ApplicationController.CeptrInterface.Embody(
    ApplicationController.CeptrInterface.RootSymbolsNode,
    ApplicationController.CeptrInterface.RootStructuresNode,
    matchResultTreeID,
    asciiTreeID
  );

  DumpOutput(embodyID);
}</pre>
<h4>Parsing the Match String</h4>
<p>As mentioned earlier, we again need to parse the human-readable string
representing our match expression into a Semtrex expression:</p>
<pre>public void ToMatchAgainst(object sender, EventArgs args)
{
  matchAgainstID = ApplicationController.CeptrInterface.ParseSemtrex(
    ApplicationController.CeptrInterface.RootSymbolsNode,
    ApplicationController.CeptrInterface.RootStructuresNode,
    View.tbMatchAgainst.Text
  );

  DumpOutput(matchAgainstID);
}</pre>
<h4>Matching Against the Embodied Semtrex</h4>
<p>Finally, in our last step, we use the <code>embodyID</code> from above along with the <code>matchAgainstID</code>
to match the embodied tree to the Semtrex match expression:</p>
<pre>public void MatchAgainstMatches(object sender, EventArgs args)
{
  bool ret = ApplicationController.CeptrInterface.MatchTest(matchAgainstID, embodyID);

  View.tbMatchResult2.Text=(ret ? &quot;True&quot; : &quot;False&quot;);
}
</pre>
<h2>On the 'C' Side</h2>
<p>As mentioned in the introduction, Eric implemented the actual algorithms in C 
for portability and performance.&nbsp; He's also written a large suite of unit 
tests which we'll give an example of as well.</p>
<h3>Semtrex Parsing</h3>
<p>Some of the Semtrex parsing was inspired by Russ Cox' article
<a href="https://web.archive.org/web/20150218105004/http:/swtch.com/~rsc/regexp/regexp1.html">
Regular Expression Matching Can Be Simple and Fast</a>, and in particular the 
algorithm for flattening an non-finite automata (NFA) to a finite one.&nbsp; 
Here, for example, is the C code that create the finite automata:</p>
<pre>/**
* Given a Semtrex tree, build a partial FSA (returned via in as a pointer to the starting state, a list of output states, and a count of the total number of states created).
*/
char * __stx_makeFA(T *t,SState **in,Ptrlist **out,int level,int *statesP) {
SState *s,*i,*last,*s1,*s2;
Ptrlist *o,*o1;
char *err;
int state_type = -1;
int x;
SemanticID group_symbol;
int group_id;
T *v;

int c = _t_children(t);
Symbol sym = _t_symbol(t);
switch(sym.id) {
  case SEMTREX_VALUE_LITERAL_ID:
  case SEMTREX_VALUE_LITERAL_NOT_ID:
    state_type = StateValue;
    s = state(state_type,statesP);
    s-&gt;data.value.flags = (sym.id == SEMTREX_VALUE_LITERAL_NOT_ID) ? LITERAL_NOT : 0;
    // copy the value set (which must be the first child) from the semtrex into the state
    v = _t_child(t,1);
    if (!v) {
      raise_error0(&quot;expecting value or SEMTREX_VALUE_SET as first child of SEMTREX_VALUE_LITERAL&quot;);
    }
    if (semeq(_t_symbol(v),SEMTREX_VALUE_SET)) s-&gt;data.value.flags |= LITERAL_SET;

    s-&gt;data.value.values = _t_clone(v);
    *in = s;
    s-&gt;transition = level;
    *out = list1(&amp;s-&gt;out);
    break;

  case SEMTREX_SYMBOL_LITERAL_ID:
  case SEMTREX_SYMBOL_LITERAL_NOT_ID:
    state_type = StateSymbol;

    v = _t_child(t,1);
    int is_set;
    Symbol vsym = _t_symbol(v);
    if (!v || !((is_set = semeq(SEMTREX_SYMBOL_SET,vsym)) || semeq(SEMTREX_SYMBOL,vsym))) {
      raise_error0(&quot;expecting SEMTREX_SYMBOL_SET or SEMTREX_SYMBOL as first child of SEMTREX_SYMBOL_LITERAL&quot;);
    }
    if (c &gt; 2) return &quot;Symbol literal must have 0 or 1 children other than the symbol/set&quot;;
    s = state(state_type,statesP);
    s-&gt;data.symbol.flags = (sym.id == SEMTREX_SYMBOL_LITERAL_NOT_ID) ? LITERAL_NOT : 0;
    if (is_set) s-&gt;data.symbol.flags |= LITERAL_SET;
    s-&gt;data.symbol.symbols = _t_clone(v);
    *in = s;
    if (c &gt; 1) {
      s-&gt;transition = TransitionDown;
      err = __stx_makeFA(_t_child(t,2),&amp;i,&amp;o,level-1,statesP);
      if (err) return err;
      s-&gt;out = i;
      *out = o;
    }
    else {
      s-&gt;transition = level;
      *out = list1(&amp;s-&gt;out);
    }
    break;

  case SEMTREX_SYMBOL_ANY_ID:
    state_type = StateAny;
    if (c &gt; 1) return &quot;Symbol any must have 0 or 1 children&quot;;

    s = state(state_type,statesP);

    *in = s;
    if (c &gt; 0) {
      s-&gt;transition = TransitionDown;
      err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level-1,statesP);
      if (err) return err;
      s-&gt;out = i;
      *out = o;
    }
    else {
      s-&gt;transition = level;
      *out = list1(&amp;s-&gt;out);
    }
    break;

  case SEMTREX_SEQUENCE_ID:
    if (c == 0) return &quot;Sequence must have children&quot;;
    last = 0;
    for(x=c;x&gt;=1;x--) {
      err = __stx_makeFA(_t_child(t,x),&amp;i,&amp;o,level,statesP);
      if (err) return err;

      if (last) patch(o,last,level);
      else *out = o;
      last = i;
      *in = i;
    }
    break;

  case SEMTREX_OR_ID:
    if (c != 2) return &quot;Or must have 2 children&quot;;
    s = state(StateSplit,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    err = __stx_makeFA(_t_child(t,2),&amp;i,&amp;o1,level,statesP);
    if (err) return err;
    s-&gt;out1 = i;
    *out = append(o,o1);
    break;

  case SEMTREX_ZERO_OR_MORE_ID:
    if (c != 1) return &quot;Star must have 1 child&quot;;
    s = state(StateSplit,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    patch(o,s,level);
    *out = list1(&amp;s-&gt;out1);
    break;

  case SEMTREX_ONE_OR_MORE_ID:
    if (c != 1) return &quot;Plus must have 1 child&quot;;
    s = state(StateSplit,statesP);
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    *in = i;
    s-&gt;out = i;
    patch(o,s,level);
    *out = list1(&amp;s-&gt;out1);
    break;

  case SEMTREX_ZERO_OR_ONE_ID:
    if (c != 1) return &quot;Question must have 1 child&quot;;
    s = state(StateSplit,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    *out = append(o,list1(&amp;s-&gt;out1));
    break;

  case SEMTREX_GROUP_ID:
    if (c != 1) return &quot;Group must have 1 child&quot;;
    s = state(StateGroupOpen,statesP);
    *in = s;
    group_symbol = *(SemanticID *)_t_surface(t);
    group_id = ++G_group_id;
    s-&gt;data.groupo.symbol = group_symbol;
    s-&gt;data.groupo.uid = group_id;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    s1 = state(StateGroupClose,statesP);
    patch(o,s1,level);
    s1-&gt;data.groupc.openP = s;
    *out = list1(&amp;s1-&gt;out);
    break;

  case SEMTREX_DESCEND_ID:
    if (c != 1) return &quot;Descend must have 1 child&quot;;
    s = state(StateDescend,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level-1,statesP);
    if (err) return err;
    s-&gt;out = i;
    *out = o;
    break;

  case SEMTREX_NOT_ID:
    if (c != 1) return &quot;Not must have 1 child&quot;;
    s = state(StateNot,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    *out = append(o,list1(&amp;s-&gt;out1));
    break;

  case SEMTREX_WALK_ID:
    if (c != 1) return &quot;Walk must have 1 child&quot;;
    s = state(StateWalk,statesP);
    *in = s;
    err = __stx_makeFA(_t_child(t,1),&amp;i,&amp;o,level,statesP);
    if (err) return err;
    s-&gt;out = i;
    *out = o;
    break;

  default:
    return &quot;Unknown SEMTREX SYMBOL&quot;;
  }
return 0;
}

/**
* wrapper function for building the finite state automata recursively and patching it to the final match state
*/
SState * _stx_makeFA(T *t,int *statesP) {
  SState *in;
  Ptrlist *o;
  G_group_id = 0;
  char *err = __stx_makeFA(t,&amp;in,&amp;o,0,statesP);
  if (err != 0) {raise_error0(err);}
  patch(o,&amp;matchstate,0);
  return in;
}</pre>
<h3>Unit Tests</h3>
<p>We'll look at the unit test for the above code.&nbsp; First, a couple macros:</p>
<pre>/// macro to add a single symbol literal to semtrex tree
#define _sl(t,s) __sl(t,0,1,s)

/// macro to add a single symbol literal not to semtrex tree
#define _sln(t,s) __sl(t,1,1,s)</pre>
<p>These are helpers for calling a function to create a Semtrex symbols set:</p>
<pre>/**
* utility function to create a semtrex litteral symbol set
*/
T *__sl(T *p, int not,int count, ...) {
  va_list symbols;
  T *t = _t_newr(p,not ? SEMTREX_SYMBOL_LITERAL_NOT : SEMTREX_SYMBOL_LITERAL);
  T *ss = count &gt; 1 ? _t_newr(t,SEMTREX_SYMBOL_SET) : t;
  va_start(symbols,count);
  int i;
  for(i=0;i&lt;count;i++) {
    _t_news(ss,SEMTREX_SYMBOL,va_arg(symbols,Symbol));
  }
  va_end(symbols);
  return t;
}</pre>
<p>This is employed in the function that creates the test Semtrex:</p>
<pre>
T *_makeTestSemtrex1() {
  // /TEST_STR_SYMBOL/(1/11/111),2,3
  T *s = _sl(0,TEST_STR_SYMBOL);
  T *ss = _t_newi(s,SEMTREX_SEQUENCE,0);
  T *s1 = _sl(ss,sy1);
  T *s11 = _sl(s1,sy11);
  T *s111 = _sl(s11,sy111);
  T *s2 = _sl(ss,sy2);
  T *s3 = _sl(ss,sy3);
  return s;
}
</pre>
<p>Utilized by the test function:</p>
<pre>void testMakeFA() {
  SState *s1, *s2, *s3, *s4, *s5, *s6;
  T *s = _makeTestSemtrex1();

  int states = 0;
  SState *sa = _stx_makeFA(s,&amp;states);
  spec_is_equal(states,6);

  spec_state_equal(sa,StateSymbol,TransitionDown,TEST_STR_SYMBOL);

  s1 = sa-&gt;out;
  spec_state_equal(s1,StateSymbol,TransitionDown,sy1);

  s2 = s1-&gt;out;
  spec_state_equal(s2,StateSymbol,TransitionDown,sy11);

  s3 = s2-&gt;out;
  spec_state_equal(s3,StateSymbol,-2,sy111);

  s4 = s3-&gt;out;
  spec_state_equal(s4,StateSymbol,TransitionNextChild,sy2);

  s5 = s4-&gt;out;
  spec_state_equal(s5,StateSymbol,TransitionUp,sy3);

  s6 = s5-&gt;out;
  spec_is_equal(s6-&gt;type,StateMatch);

  spec_is_ptr_equal(s6-&gt;out,NULL);

  _stx_freeFA(sa);
  _t_free(s);
}</pre>
<h2>Semtrex Tokens - Detail Section for Regular Expression Geeks</h2>
<p>The format for this section describes each:</p>
<ul>
	<li>Semantic symbol (the sub-header in this section)</li>
<li>Its textual representation</li>
	<li>What it matches</li>
<li>Example</li>
<li>Additional explanation</li>
</ul>
<h3>SEMTREX_SYMBOL_LITERAL</h3>
<p>The name of the symbol that it matches</p>
<p>It matches a tree node of a specific symbol</p>
<pre>/%HomeLocation/(lat=42.25,lon=73.25)</pre>
		<p>HomeLocation is the symbol literal<h3>SEMTREX_VALUE_LITERAL</h3>
<p>The name of the symbol = a value (quoted from text)</p>
<p>It matches a tree node of the given symbol and a 
		specific value</p><pre>/%HomeLocation/(lat=42.25,lon=73.25)</pre><p>lat=42.25 
		matches on both the symbol &quot;lat&quot; and the value &quot;42.25&quot;<h3>SEMTREX_SYMBOL_LITERAL_NOT</h3>
<p>! followed by the symbol name</p>
<p>It matches a tree node of any symbol except the given one</p>
<p>!PUNCTUATION</p>
<h3>SEMTREX_VALUE_LITERAL_NOT</h3>
<p>The name of the symbol != a value</p>
<p>It matches a tree node of the given symbol&nbsp; and any 
		value that doesn't match it</p><pre>ASCII_CHAR!=' '+</pre>Matches any ASCII character node whose 
		value doesn't equal space<h3>SEMTREX_SYMBOL_SET</h3>
{comma delimited symbols}<p>It matches a tree node in the given set of symbols</p><pre>{lat, lon}</pre><p>Matches a lat or lon node<h3>SEMTREX_VALUE_SET</h3>
<p>symbol = { comma delimited values }<br>
				symbol != { comma delimited values }<p>It matches a tree node whose symbol is the given type 
		and whose value matches (or doesn't match) a value in the set</p><pre>ASCII_CHAR!={'/','?',' '}</pre><p>Matches an ASCII character 
		with one of /, ?, or space</p>
<h3>SEMTREX_ZERO_OR_MORE</h3>
<p>The textual representation is a * (asterisk)</p>
<p>It matches zero or more sibling nodes</p><pre>ASCII_CHAR!={'/','?',' '}*</pre><p>Matches zero or more ASCII 
		characters nodes whose value is not in the set /, ?, and space<h3>SEMTREX_ONE_OR_MORE</h3>
<p>The textual representation is a + (plus)</p>
<p>It matches one or more sibling nodes</p><pre>ASCII_CHAR!={'/','?',' '}+</pre><p>Matches one or more ASCII 
		characters nodes whose value is not in the set /, ?, and space<h3>SEMTREX_ZERO_OR_ONE</h3>
<p>The textual representation is a ? (questionmark)<p>It matches zero one sibling nodes</p><pre>ASCII_CHAR!={'/','?',' '}?</pre><p>Matches zero or one ASCII 
		characters nodes whose value is not in the set /, ?, and space<h3>SEMTREX_SYMBOL_ANY</h3>
<p>The textual representation is a . (dot)</p>
<p>It matches a tree node of any symbol</p><pre>.*</pre><p>Zero or more of any symbol<h3>SEMTREX_OR</h3>
<p>The textual representation is a | (pipe)</p>
<p>It matches a tree that matches one expression or another 
		express.&nbsp; On either side of the or can be any Semtrex expression</p><pre>lon=72.25 | lon=68.32
HomeLocation | BusinessLocation</pre><p>The above illustrates matching two 
		different expressions.&nbsp; The first one is a value literal match, the 
		second one is a symbol match.</p>
<h3>SEMTREX_SEQUENCE</h3>
<p>The textual representation is a , (comma)</p>
<p>Matches a sibling tree followed by another sibling tree, 
		etc.</p><pre>ASCII_CHAR='H',ASCII_CHAR='T',ASCII_CHAR='T',ASCII_CHAR='P'</pre><p>Matches on the four ASCII characters HTTP<h3>SEMTREX_GROUP</h3>
<p>&lt;name : expr&gt;</p>
<p>Allows you to associate a symbolic name with what 
		matched or group larger expressions for use as part of other semtrex 
		expressions.</p><pre>&lt;HomeLocation:&lt;lat:ASCII_CHAR+&gt;,ASCII_CHAR=',',&lt;lon:ASCII_CHAR+&gt;&gt;</pre><p>
		This a naming of a sequence of a named group, a comma, and another named 
		group.<h3>SEMTREX_WALK</h3>
<p>The textual representation is a % (percent sign)</p>
<p>The following Semtrex expression can match anywhere in 
		the tree rather than the current matching node position.</p><pre>/%HomeLocation/(lat=42.25,lon=73.25)</pre><p>This would match 
		on a specific home location found somewhere in the tree rather at the 
		root (in this example.)<h3>Siblings</h3>
<p>() Parentheses for disambiguating what's a sibling and 
		what's a child.&nbsp; There is no Semtrex symbol for this because a tree 
		encodes this information directly.</p>
<h2>References</h2>

<p>1.&nbsp; <a href="http://en.wikipedia.org/wiki/Semantics">
http://en.wikipedia.org/wiki/Semantics</a><br>
2.&nbsp; <a href="http://en.wikipedia.org/wiki/Great-circle_distance">
http://en.wikipedia.org/wiki/Great-circle_distance</a> <br>
3. <span class="reference-text"><span class="citation web">
<a rel="nofollow" class="external text" href="http://www.w3.org/2001/sw/">&quot;W3C
Semantic Web Activity&quot;</a>.
<a title="World Wide Web Consortium" href="http://en.wikipedia.org/wiki/World_Wide_Web_Consortium">
World Wide Web Consortium</a> (W3C). November 7, 2011<span class="reference-accessdate">.
Retrieved November 26, 2011</span>.<br>
</span></span><span class="citation web">4.
<a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee">
http://en.wikipedia.org/wiki/Tim_Berners-Lee</a> <br>
</span>5. <span class="reference-text"><span class="citation journal">Berners-Lee,
Tim; James Hendler; Ora Lassila (May 17, 2001).
<a rel="nofollow" class="external text" href="http://www.sciam.com/article.cfm?id=the-semantic-web&print=true">
&quot;The Semantic Web&quot;</a>. <i>Scientific American Magazine</i><span class="reference-accessdate">.
Retrieved March 26, 2008</span>.<br>
</span></span>6. <a href="http://dictionary.reference.com/browse/Phylogeny">
http://dictionary.reference.com/browse/Phylogeny</a> <br>
7. <a href="http://en.wikipedia.org/wiki/Parse_tree">
http://en.wikipedia.org/wiki/Parse_tree</a> <br>
8. <a href="http://en.wikipedia.org/wiki/BackusNaur_Form">
http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form</a> <br>
9. <a href="http://en.wikipedia.org/wiki/Ontology_engineering">
http://en.wikipedia.org/wiki/Ontology_engineering</a> <br>
10. <a href="http://tools.ietf.org/html/rfc5321">
http://tools.ietf.org/html/rfc5321</a> <br>
11. <a href="http://json.org/">http://json.org/</a> </p>

</body>

</html>
